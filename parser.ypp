%{
#include "hw3_output.hpp"
#include "bp.hpp"
#include "NonTerminalClasses.h"
#include "SymbolTable.h"
#include <vector>
#include <iostream>
#include <map>

using namespace std;
using namespace output;

void yyerror(const char*);
bool isNumbers(const Object* type1, const Object* type2);
bool isBools(const Object* type1, const Object* type2);
void destroyOnExit();
void destroyAll();
void endOfScope();
void initialEmit();
bool isRegister(std::string val);
std::string toLlvmTypes(std::vector<ProtoType*> types);
std::string toLlvmArgs(std::vector<std::string> typesOfFunc, std::vector<ProtoType*> args);
std::string getNextReg();
std::string getNextGlobal();
SymbolTable symbolTable;
int whileCounter = 0;
std::vector<Bool*> whileVec;
int regCounter = 0;
std::map<std::string, int> globalDict;
ProtoType* returnType = nullptr;
std::vector<Object*> toDeleteList;
extern int yylineno;
extern int yylex();
%}


/* Declarations */
%define api.value.type { Object* }

%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%token CONST
%token TRUE
%token FALSE
%token RETURN
%token IF
%token ELSE
%token WHILE
%token BREAK
%token CONTINUE 
%token SC
%token COMMA
%token LPAREN
%token RPAREN
%token LBRACE
%token RBRACE
%token ID
%token NUM
%token STRING

/* -----operators----- */
%token ASSIGN
%token OR
%token AND
%token RELOP_EQ
%token RELOP_RELATION
/* %token PLUS_MINUS */
%token PLUS
%token MINUS
/* %token PRODUCT_DEVISION */
%token PRODUCT
%token DEVISION
%token NOT
/* ------------------- */

%right ASSIGN
%left OR
%left AND
%left RELOP_EQ
%nonassoc RELOP_RELATION
/* %left PLUS_MINUS */
%left PLUS
%left MINUS
/* %left PRODUCT_DEVISION */
%left PRODUCT
%left DEVISION
%right NOT
%right LPAREN
%left RPAREN

%%
/* Rules */
Program: { 
            //cout << 1 << endl;
            ProtoType* voidTmp = new Void();
            ProtoType* stringTmp = new String();
            ProtoType* intTmp = new Int();
            toDeleteList.push_back(voidTmp);
            toDeleteList.push_back(stringTmp);
            toDeleteList.push_back(intTmp);
            symbolTable.insertAtTop("print", Func(*voidTmp, "random1", *stringTmp));
            symbolTable.insertAtTop("printi", Func(*voidTmp, "random2", *intTmp));
            initialEmit();
         } Funcs { 
              //cout << 2 << endl;
          };
Funcs: FuncDecl Funcs //{ cout << 2 << "a" << endl; } //maybe need to flip
            | 
;
FuncDecl: RetType ID LPAREN Formals RPAREN {
                //cout << 3 << endl;
                toDeleteList.push_back($2);
                //cout << "3a" << endl;
                if (symbolTable.findId((dynamic_cast<Id*>($2)->id))) {
                    //cout << "3b" << endl;
                    errorDef(yylineno, (dynamic_cast<Id*>($2)->id));
                    destroyOnExit();
                } else {
                    //cout << "3c" << endl;
                    symbolTable.insertAtTop(dynamic_cast<Id*>($2)->id, Func(*(dynamic_cast<ProtoType*>($1)), dynamic_cast<Formals*>($4)->getNames(), dynamic_cast<Formals*>($4)->getTypes()));
                    symbolTable.pushNewEntry();
                    //cout << "3d" << endl;
                    if(symbolTable.addParameters(*(dynamic_cast<Formals*>($4)), yylineno)) {
                        destroyOnExit();
                    }
                    //cout << "TEST after add parameters: value of parameter 'val' is: " << symbolTable.getValueById("val") << endl;
                    //cout << "3e" << endl;
                    returnType = dynamic_cast<ProtoType*>($1);
                    string cmdRetType;
                    if(returnType->isByte()) {
                        cmdRetType = "i8";
                    } else if(returnType->isInt()) {
                        cmdRetType = "i32";
                    } else if(returnType->isBool()) {
                        cmdRetType = "i1";
                    } else if(returnType->isVoid()) {
                        cmdRetType = "void";
                    }
                    //cout << "3f" << endl;
                    string cmd = "define ";
                    //cout << "3g" << endl;
                    cmd += cmdRetType + " @" + dynamic_cast<Id*>($2)->id + "("+ toLlvmTypes(dynamic_cast<Formals*>($4)->getTypes()) + ") {";
                    //cout << "3h" << endl;
                    CodeBuffer::instance().emit(cmd);
                    CodeBuffer::instance().emit("\%stack = alloca i32, i32 50");
                }
                //cout << "end of 3" << endl;
          } LBRACE Statements RBRACE {
                //cout << 4 << endl;
                string line;
                if(returnType->isBool()) {
                    line = "ret i1 0";
                } else if(returnType->isInt()) {
                    line = "ret i32 0";
                } else if(returnType->isByte()) {
                    line = "ret i8 0";
                } else {
                    line = "ret void";
                }
                CodeBuffer::instance().emit(line);
                endOfScope();
                returnType = nullptr;
                CodeBuffer::instance().emit("}");
          }
;
RetType:      Type { $$ = $1;  /*cout << 5 << endl;*/}
            | VOID { $$ = new Void(); toDeleteList.push_back($$); /*cout << 6 << endl;*/}
;
Formals:     FormalsList {/*cout << 7 << endl;*/ $$ = new Formals(*(dynamic_cast<FormalsList*>($1))); toDeleteList.push_back($$); }
            | { /*cout << 8 << endl;*/ $$ = new Formals(); toDeleteList.push_back($$); }
;
FormalsList: FormalDecl COMMA FormalsList { /*cout << 9 << endl;*/ $$ = new FormalsList(*dynamic_cast<FormalDecl*>($1), dynamic_cast<FormalsList*>($3)->getList()); toDeleteList.push_back($$); }// delete $1; delete $3;} /* maybe need to flip */
            | FormalDecl { /*cout << 10 << endl;*/ $$ = new FormalsList(*dynamic_cast<FormalDecl*>($1)); toDeleteList.push_back($$); }
;
FormalDecl: TypeAnnotation Type ID {
    //cout << 11 << endl;
    toDeleteList.push_back($3);
    if(!symbolTable.findId((dynamic_cast<Id*>($3)->id))) {
        dynamic_cast<ProtoType*>($2)->setConst(dynamic_cast<TypeAnnotation*>($1)->getIsConst());
        $$ = new FormalDecl(*(dynamic_cast<ProtoType*>($2)), dynamic_cast<Id*>($3)->id);
        toDeleteList.push_back($$);
    } else {
        errorDef(yylineno, (dynamic_cast<Id*>($3)->id));
        destroyOnExit();
    }
};
Statements:  Statements {int loc = CodeBuffer::instance().emit("br label @"); string lab = CodeBuffer::instance().genLabel(); CodeBuffer::instance().bpatch(CodeBuffer::makelist({loc, BranchLabelIndex::FIRST}), lab);} Statement {
                $$ = new Bool();
                toDeleteList.push_back($$);
                dynamic_cast<Bool*>($$)->setTrueList(CodeBuffer::merge(dynamic_cast<Bool*>($3)->getTrueList(), dynamic_cast<Bool*>($1)->getTrueList()));
                dynamic_cast<Bool*>($$)->setFalseList(CodeBuffer::merge(dynamic_cast<Bool*>($3)->getFalseList(), dynamic_cast<Bool*>($1)->getFalseList()));
            }
            | Statement {
                $$ = new Bool();
                toDeleteList.push_back($$);
                dynamic_cast<Bool*>($$)->setTrueList(dynamic_cast<Bool*>($1)->getTrueList());
                dynamic_cast<Bool*>($$)->setFalseList(dynamic_cast<Bool*>($1)->getFalseList());
            }
;
Statement: OpenStatement { 
                $$ = new Bool();
                toDeleteList.push_back($$);
                dynamic_cast<Bool*>($$)->setTrueList(dynamic_cast<Bool*>($1)->getTrueList()); 
                dynamic_cast<Bool*>($$)->setFalseList(dynamic_cast<Bool*>($1)->getFalseList());
            }
			| ClosedStatement {
                $$ = new Bool();
                toDeleteList.push_back($$);
                dynamic_cast<Bool*>($$)->setTrueList(dynamic_cast<Bool*>($1)->getTrueList()); 
                dynamic_cast<Bool*>($$)->setFalseList(dynamic_cast<Bool*>($1)->getFalseList());
            }
;
OpenStatement:  IF ifMarker LPAREN Exp IfWhileMarker RPAREN ClosedStatement { 
                    //cout << 12 << endl;
                    $$ = new Bool();
                    toDeleteList.push_back($$);
                    dynamic_cast<Bool*>($$)->setTrueList(CodeBuffer::merge(dynamic_cast<Bool*>($$)->getTrueList(), dynamic_cast<Bool*>($7)->getTrueList()));
                    dynamic_cast<Bool*>($$)->setFalseList(CodeBuffer::merge(dynamic_cast<Bool*>($$)->getFalseList(), dynamic_cast<Bool*>($7)->getFalseList()));
                    int place = CodeBuffer::instance().emit("br label @");
                    pair<int,BranchLabelIndex> newPair = make_pair(place, BranchLabelIndex::FIRST);


                    CodeBuffer::instance().bpatch(dynamic_cast<Bool*>($4)->getTrueList(), dynamic_cast<Bool*>($5)->getLabel());
                    CodeBuffer::instance().bpatch(CodeBuffer::merge(dynamic_cast<Bool*>($4)->getFalseList(), CodeBuffer::makelist(newPair)), CodeBuffer::instance().genLabel());

                    endOfScope();  
                }
                | IF ifMarker LPAREN Exp IfWhileMarker RPAREN OpenStatement { 
                    //cout << 13 << endl;
                    $$ = new Bool();
                    toDeleteList.push_back($$);
                    dynamic_cast<Bool*>($$)->setTrueList(CodeBuffer::merge(dynamic_cast<Bool*>($$)->getTrueList(), dynamic_cast<Bool*>($7)->getTrueList()));
                    dynamic_cast<Bool*>($$)->setFalseList(CodeBuffer::merge(dynamic_cast<Bool*>($$)->getFalseList(), dynamic_cast<Bool*>($7)->getFalseList()));

                    int place = CodeBuffer::instance().emit("br label @");
                    pair<int,BranchLabelIndex> newPair = make_pair(place, BranchLabelIndex::FIRST);


                    CodeBuffer::instance().bpatch(dynamic_cast<Bool*>($4)->getTrueList(), dynamic_cast<Bool*>($5)->getLabel());
                    CodeBuffer::instance().bpatch(CodeBuffer::merge(dynamic_cast<Bool*>($4)->getFalseList(), CodeBuffer::makelist(newPair)), CodeBuffer::instance().genLabel());
                    endOfScope();
                }
                | IF ifMarker LPAREN Exp IfWhileMarker RPAREN ClosedStatement ElseMarker ELSE OpenStatement { 
                    //cout << 14 << endl;
                    $$ = new Bool();
                    toDeleteList.push_back($$);
                    dynamic_cast<Bool*>($$)->setTrueList(CodeBuffer::merge(dynamic_cast<Bool*>($$)->getTrueList(), dynamic_cast<Bool*>($7)->getTrueList()));
                    dynamic_cast<Bool*>($$)->setFalseList(CodeBuffer::merge(dynamic_cast<Bool*>($$)->getFalseList(), dynamic_cast<Bool*>($7)->getFalseList()));
                    dynamic_cast<Bool*>($$)->setTrueList(CodeBuffer::merge(dynamic_cast<Bool*>($$)->getTrueList(), dynamic_cast<Bool*>($10)->getTrueList()));
                    dynamic_cast<Bool*>($$)->setFalseList(CodeBuffer::merge(dynamic_cast<Bool*>($$)->getFalseList(), dynamic_cast<Bool*>($10)->getFalseList()));

                    int place = CodeBuffer::instance().emit("br label @");
                    pair<int,BranchLabelIndex> newPair = make_pair(place, BranchLabelIndex::FIRST);

                    CodeBuffer::instance().bpatch(dynamic_cast<Bool*>($4)->getTrueList(), dynamic_cast<Bool*>($5)->getLabel());
                    CodeBuffer::instance().bpatch(dynamic_cast<Bool*>($4)->getFalseList(), dynamic_cast<Bool*>($8)->getLabel());
                    CodeBuffer::instance().bpatch(CodeBuffer::merge(dynamic_cast<Bool*>($8)->getTrueList(), CodeBuffer::makelist(newPair)), CodeBuffer::instance().genLabel());
                    
                    endOfScope();
                }
                | WHILE WhileMarker LPAREN Exp IfWhileMarker RPAREN OpenStatement { 
                    //cout << 15 << endl;
                    $$ = new Bool();
                    toDeleteList.push_back($$);
                    //dynamic_cast<Bool*>($$)->setTrueList(CodeBuffer::merge(dynamic_cast<Bool*>($$)->getTrueList(), dynamic_cast<Bool*>($7)->getTrueList()));
                    //dynamic_cast<Bool*>($$)->setFalseList(CodeBuffer::merge(dynamic_cast<Bool*>($$)->getFalseList(), dynamic_cast<Bool*>($7)->getFalseList()));
                    dynamic_cast<Bool*>($$)->setTrueList(dynamic_cast<Bool*>($7)->getTrueList());
                    dynamic_cast<Bool*>($$)->setFalseList(dynamic_cast<Bool*>($7)->getFalseList());

                    CodeBuffer::instance().emit("br label %" + dynamic_cast<Bool*>($2)->getLabel());
                    CodeBuffer::instance().bpatch(dynamic_cast<Bool*>($4)->getTrueList(), dynamic_cast<Bool*>($5)->getLabel());
                    string afterWhileLab = CodeBuffer::instance().genLabel();
                    CodeBuffer::instance().bpatch(dynamic_cast<Bool*>($4)->getFalseList(), afterWhileLab);
                    
                    //cout << "after while label is: " << afterWhileLab << endl;
                    //Note: was $7, i changed to $$ instead to see if it will change something
                    CodeBuffer::instance().bpatch(dynamic_cast<Bool*>($$)->getTrueList(), afterWhileLab); //all the breaks goto after the while
                    CodeBuffer::instance().bpatch(dynamic_cast<Bool*>($$)->getFalseList(), dynamic_cast<Bool*>($2)->getLabel()); //all the continues goto the start
                    endOfScope(); 
                    whileCounter--;
                }
;
//Because we are a lazy bum, we decided that truelist will represent the "breaklist" and falselist will represent the "continuelist" :)
ClosedStatement:    NonIfStatement {
                        $$ = new Bool();
                        toDeleteList.push_back($$);
                        if($1->isBool()) {  //Checks if NonIfStatement went through break or continue |:^)
                            //dynamic_cast<Bool*>($$)->setTrueList(CodeBuffer::merge(dynamic_cast<Bool*>($$)->getTrueList(), dynamic_cast<Bool*>($1)->getTrueList()));
                            //dynamic_cast<Bool*>($$)->setFalseList(CodeBuffer::merge(dynamic_cast<Bool*>($$)->getFalseList(), dynamic_cast<Bool*>($1)->getFalseList()));
                            dynamic_cast<Bool*>($$)->setTrueList(dynamic_cast<Bool*>($1)->getTrueList());
                            dynamic_cast<Bool*>($$)->setFalseList(dynamic_cast<Bool*>($1)->getFalseList());
                        }
                    }
                    | IF ifMarker LPAREN Exp IfWhileMarker RPAREN ClosedStatement ElseMarker ELSE ClosedStatement { 
                        //cout << 16 << endl;
                        $$ = new Bool();
                        toDeleteList.push_back($$);
                        dynamic_cast<Bool*>($$)->setTrueList(CodeBuffer::merge(dynamic_cast<Bool*>($$)->getTrueList(), dynamic_cast<Bool*>($7)->getTrueList()));
                        dynamic_cast<Bool*>($$)->setFalseList(CodeBuffer::merge(dynamic_cast<Bool*>($$)->getFalseList(), dynamic_cast<Bool*>($7)->getFalseList()));
                        dynamic_cast<Bool*>($$)->setTrueList(CodeBuffer::merge(dynamic_cast<Bool*>($$)->getTrueList(), dynamic_cast<Bool*>($10)->getTrueList()));
                        dynamic_cast<Bool*>($$)->setFalseList(CodeBuffer::merge(dynamic_cast<Bool*>($$)->getFalseList(), dynamic_cast<Bool*>($10)->getFalseList()));
                        int place = CodeBuffer::instance().emit("br label @");
                        pair<int,BranchLabelIndex> newPair = make_pair(place, BranchLabelIndex::FIRST);     

                        CodeBuffer::instance().bpatch(dynamic_cast<Bool*>($4)->getTrueList(), dynamic_cast<Bool*>($5)->getLabel());
                        CodeBuffer::instance().bpatch(dynamic_cast<Bool*>($4)->getFalseList(), dynamic_cast<Bool*>($8)->getLabel());
                        CodeBuffer::instance().bpatch(CodeBuffer::merge(dynamic_cast<Bool*>($8)->getTrueList(), CodeBuffer::makelist(newPair)), CodeBuffer::instance().genLabel());
                        endOfScope();
                    }
                    | WHILE WhileMarker LPAREN Exp IfWhileMarker RPAREN ClosedStatement { 
                        //cout << 17 << endl;
                        $$ = new Bool();
                        toDeleteList.push_back($$);
                        //dynamic_cast<Bool*>($$)->setTrueList(CodeBuffer::merge(dynamic_cast<Bool*>($$)->getTrueList(), dynamic_cast<Bool*>($7)->getTrueList()));
                        //dynamic_cast<Bool*>($$)->setFalseList(CodeBuffer::merge(dynamic_cast<Bool*>($$)->getFalseList(), dynamic_cast<Bool*>($7)->getFalseList()));
                        dynamic_cast<Bool*>($$)->setTrueList(dynamic_cast<Bool*>($7)->getTrueList());
                        dynamic_cast<Bool*>($$)->setFalseList(dynamic_cast<Bool*>($7)->getFalseList());

                        CodeBuffer::instance().emit("br label %" + dynamic_cast<Bool*>($2)->getLabel());
                        CodeBuffer::instance().bpatch(dynamic_cast<Bool*>($4)->getTrueList(), dynamic_cast<Bool*>($5)->getLabel());
                        string afterWhileLab = CodeBuffer::instance().genLabel();
                        CodeBuffer::instance().bpatch(dynamic_cast<Bool*>($4)->getFalseList(), afterWhileLab);
                        
                        //cout << "after while label is: " << afterWhileLab << endl;
                        //Note: was $7 instead of $$. Changed to see what will happen
                        CodeBuffer::instance().bpatch(dynamic_cast<Bool*>($$)->getTrueList(), afterWhileLab); //all the breaks goto after the while
                        CodeBuffer::instance().bpatch(dynamic_cast<Bool*>($$)->getFalseList(), dynamic_cast<Bool*>($2)->getLabel()); //all the continues goto the start
                        endOfScope(); 
                        whileCounter--; 
                    }
;
ifMarker: {
        $$ = new Bool();
        toDeleteList.push_back($$);
        int loc = CodeBuffer::instance().emit("br label @");
        string lab = CodeBuffer::instance().genLabel();
        CodeBuffer::instance().bpatch(CodeBuffer::makelist({loc, BranchLabelIndex::FIRST}), lab);
    };
WhileMarker: { 
        /*cout << 18 << endl;*/ //call f(5) f(int a)
        whileCounter++;
        $$ = new Bool();
        toDeleteList.push_back($$);
        int loc = CodeBuffer::instance().emit("br label @");
        string lab = CodeBuffer::instance().genLabel();
        dynamic_cast<Bool*>($$)->setLabel(lab);
        CodeBuffer::instance().bpatch(CodeBuffer::makelist({loc, BranchLabelIndex::FIRST}), lab);
    };
IfWhileMarker: { 
        //cout << 19 << endl;
        if ($0->isBool()) {
            symbolTable.pushNewEntry();
            $$ = new Bool();
            toDeleteList.push_back($$);
            int loc = CodeBuffer::instance().emit("br label @");
            string lab = CodeBuffer::instance().genLabel();
            dynamic_cast<Bool*>($$)->setLabel(lab);
            CodeBuffer::instance().bpatch(CodeBuffer::makelist({loc, BranchLabelIndex::FIRST}), lab);
        } else {
            errorMismatch(yylineno);
            destroyOnExit();
        }
};
ElseMarker: { 
    //cout << 20 << endl;
    endOfScope();
    symbolTable.pushNewEntry();
    $$ = new Bool();
    toDeleteList.push_back($$);
    int loc = CodeBuffer::instance().emit("br label @");
    pair<int,BranchLabelIndex> newPair = make_pair(loc, BranchLabelIndex::FIRST);
    dynamic_cast<Bool*>($$)->setTrueList(CodeBuffer::makelist(newPair));
    dynamic_cast<Bool*>($$)->setLabel(CodeBuffer::instance().genLabel());
};
NonIfStatement: LBRACE { symbolTable.pushNewEntry(); } Statements RBRACE { 
                $$ = new Bool();
                toDeleteList.push_back($$);
                dynamic_cast<Bool*>($$)->setTrueList(dynamic_cast<Bool*>($3)->getTrueList());
                dynamic_cast<Bool*>($$)->setFalseList(dynamic_cast<Bool*>($3)->getFalseList());
                endOfScope(); 
            } //{ $$ = Statement($2); } 
            | TypeAnnotation Type ID SC { 
                //cout << 21 << endl;
                toDeleteList.push_back($3);
                if (!symbolTable.findId((dynamic_cast<Id*>($3)->id))) {
                    //cout << 21 << "a" << endl;
                    string tmpLine;
                    string reg1;
                    if (dynamic_cast<TypeAnnotation*>($1)->getIsConst()) {
                        errorConstDef(yylineno);
                        destroyOnExit();
                    }
                    symbolTable.insertAtTop((dynamic_cast<Id*>($3)->id), *(dynamic_cast<ProtoType*>($2)));
                    std::string cmd;
                    if(dynamic_cast<ProtoType*>($2)->isBool()) { //var is bool
                        reg1 = getNextReg();
                        tmpLine = reg1 + " = zext i1 false to i32"; //%t0 = zext i1 false to i32
                        CodeBuffer::instance().emit(tmpLine);
                        
                    } else { //var is num
                        reg1 = getNextReg();
                        tmpLine = reg1 + " = add i32 0, 0"; //%t0 = i32 0 
                        //TODO: check if you can do i32 0
                        CodeBuffer::instance().emit(tmpLine);
                    }
                    std::string reg2 = getNextReg();
                    int offset = symbolTable.getAbsoluteOffset(dynamic_cast<Id*>($3)->id);
                    tmpLine = reg2 + " = getelementptr i32, i32* %stack, i32 " + to_string(offset); //%t1 = add i32 offset, %stack
                    CodeBuffer::instance().emit(tmpLine);
                    tmpLine = "store i32 " + reg1 + ", i32* " + reg2; //store i32 %t0, i32* %t1
                    CodeBuffer::instance().emit(tmpLine);
                    
                    
                    /*
                    reg2 = getNextReg();
                    tmpLine = reg2 + " = load i32, i32* " + reg1;
                    CodeBuffer::instance().emit(tmpLine);
                    tmpLine = "call void @printi(i32 " + reg2 + ")";
                    CodeBuffer::instance().emit(tmpLine);
                    */
                } else {
                    //cout << 21 << "b" << endl;
                    errorDef(yylineno, (dynamic_cast<Id*>($3)->id));
                    destroyOnExit();
                }
             } //$$ = Statement(nullptr); } //TODO: need to push to symbol Table and check Types
            | TypeAnnotation Type ID ASSIGN Exp SC { 
                //cout << 22 << endl;
                toDeleteList.push_back($3);
                if (!symbolTable.findId((dynamic_cast<Id*>($3)->id))) {
                    if (isNumbers($2, $5)) {
                        if ($5->isInt() && $2->isByte()) {
                            errorMismatch(yylineno);
                            destroyOnExit();
                        }
                    } else if (!isBools($2, $5)) {
                        errorMismatch(yylineno);
                        destroyOnExit();
                    }
                    dynamic_cast<ProtoType*>($2)->setConst(dynamic_cast<TypeAnnotation*>($1)->getIsConst());
                    symbolTable.insertAtTop((dynamic_cast<Id*>($3)->id), *(dynamic_cast<ProtoType*>($2)));
                                            
                    int offset = symbolTable.getAbsoluteOffset((dynamic_cast<Id*>($3)->id));
                    std::string value = dynamic_cast<ProtoType*>($5)->getValue(); //value is a terminal like b5, 13, true... or a register
                    std::string reg1 = getNextReg();
                    std::string tmpLine = reg1 + " = getelementptr i32, i32* %stack, i32 " + to_string(offset);;
                    CodeBuffer::instance().emit(tmpLine);
                    /*
                    if(isRegister(value)) {
                        std::line = "store i32 " + value + ", i32* " + reg1;
                        CodeBuffer::instance().emit(line);
                    } else { */
                    if(dynamic_cast<TypeAnnotation*>($1)->getIsConst() && dynamic_cast<ProtoType*>($5)->getIsLiteral()) { //TODO: Add flag and value for const in SymbolTableEntry! and setting and getting this value in SymbolTable by id
                        symbolTable.setValueById((dynamic_cast<Id*>($3)->id), value);
                    } else {
                        string reg2;
                        if ($5->isBool()) {
                            reg2 = getNextReg();
                            tmpLine = reg2 + " = zext i1 " + value + " to i32";
                            CodeBuffer::instance().emit(tmpLine);
                        } else if ($5->isByte()) {
                            reg2 = getNextReg();
                            tmpLine = reg2 + " = zext i8 " + value + " to i32";
                            CodeBuffer::instance().emit(tmpLine);
                        } else {
                            reg2 = value;
                        }
                        std::string line = "store i32 " + reg2 + ", i32* " + reg1;
                        CodeBuffer::instance().emit(line);

                        /*
                        reg2 = getNextReg();
                        line = reg2 + " = load i32, i32* " + reg1;
                        CodeBuffer::instance().emit(line);
                        line = "call void @printi(i32 " + reg2 + ")";
                        CodeBuffer::instance().emit(line);
                        */
                    }   
                } else {
                    errorDef(yylineno, (dynamic_cast<Id*>($3)->id));
                    destroyOnExit();
                }
            } //$$ = Statement(nullptr); }
            | ID ASSIGN Exp SC { 
                //cout << 23 << endl;
                toDeleteList.push_back($1);
                //cout << "23a" << endl;
                if (symbolTable.findId((dynamic_cast<Id*>($1)->id))) {
                    //cout << "23b" << endl;
                    ProtoType& type = symbolTable.getIdType((dynamic_cast<Id*>($1)->id));
                    if (type.isFunc()) {
                        errorUndef(yylineno, (dynamic_cast<Id*>($1)->id));
                        destroyOnExit();
                    } else if (type.getIsConst()) {
                        errorConstMismatch(yylineno);
                        destroyOnExit();
                    }
                    if (isNumbers(&type, $3)) {
                        if ($3->isInt() && type.isByte()) {
                            errorMismatch(yylineno);
                            destroyOnExit();
                        }
                    } else if (!isBools($3, &type)) {
                        errorMismatch(yylineno);
                        destroyOnExit();
                    }
                //cout << "23c" << endl;

                    //TODO: check if this is good
                    int offset = symbolTable.getAbsoluteOffset((dynamic_cast<Id*>($1)->id));
                    //cout << "23c1" << endl;
                    std::string value = dynamic_cast<ProtoType*>($3)->getValue(); //value is a terminal like b5, 13, true... or a register
                    //cout << "23d" << endl;
                    std::string reg1 = getNextReg();
                    std::string tmpLine = reg1 + " = getelementptr i32, i32* %stack, i32 " + to_string(offset);
                    CodeBuffer::instance().emit(tmpLine);
                    string line;
                    /*
                    if(isRegister(value)) {
                        cout << "23e" << endl;
                        line = "store i32 " + value + ", i32* " + reg1;
                    } else {  */
                    //cout << "23f" << endl;
                    string reg2; 
                    if ($3->isBool()) {
                        reg2 = getNextReg();
                        tmpLine = reg2 + " = zext i1 " + value + " to i32";
                        CodeBuffer::instance().emit(tmpLine);
                    } else if ($3->isByte()) {
                        reg2 = getNextReg();
                        tmpLine = reg2 + " = zext i8 " + value + " to i32";
                        CodeBuffer::instance().emit(tmpLine);
                    } else {
                        reg2 = value;
                    }
                    line = "store i32 " + reg2 + ", i32* " + reg1;
                   
                    //cout << "23g" << endl;
                    CodeBuffer::instance().emit(line);


                    /*
                    reg2 = getNextReg();
                    line = reg2 + " = load i32, i32* " + reg1;
                    CodeBuffer::instance().emit(line);
                    line = "call void @printi(i32 " + reg2 + ")";
                    CodeBuffer::instance().emit(line);
                    */
                } else {
                    errorUndef(yylineno, (dynamic_cast<Id*>($1)->id));
                    destroyOnExit();
                }
            } // $$ = Statement(nullptr); }
            | Call SC //delete $1; }
            | RETURN SC {
                if (!returnType->isVoid()) {
                    errorMismatch(yylineno);
                    destroyOnExit();
                }
                CodeBuffer::instance().emit("ret void");
            } //$$ = Statement(Void()); }
            | RETURN Exp SC { 
                //cout << 25 << endl;
                if (isNumbers($2, returnType)) {
                    if ($2->isInt() && returnType->isByte()) {
                        errorMismatch(yylineno);
                        destroyOnExit();
                    }
                } else if (!isBools($2, returnType)) {
                    errorMismatch(yylineno);
                    destroyOnExit();
                }
                string line;
                string value = dynamic_cast<ProtoType*>($2)->getValue();
                if ($2->isInt()) {
                    line = "ret i32 " + value;
                } else if ($2->isByte()) {
                    line = "ret i8 " + value;
                } else {
                    line = "ret i1 " + value;
                }
                CodeBuffer::instance().emit(line);
            }//$$ = Statement($2); }
            | BREAK SC { 
                //cout << 26 << endl;
                if (whileCounter <= 0) {
                    errorUnexpectedBreak(yylineno); 
                    destroyOnExit();
                }
                $$ = new Bool();
                toDeleteList.push_back($$);
                int loc = CodeBuffer::instance().emit("br label @");
                pair<int,BranchLabelIndex> newPair = make_pair(loc, BranchLabelIndex::FIRST);
                dynamic_cast<Bool*>($$)->setTrueList(CodeBuffer::makelist(newPair));
                //dynamic_cast<Bool*>($$)->setLabel(CodeBuffer::instance().genLabel()); //Removed this line in 26/1
            }
            | CONTINUE SC {
                //cout << 27 << endl;
                if(whileCounter <= 0) {
                    errorUnexpectedContinue(yylineno);
                    destroyOnExit();
                }
                $$ = new Bool();
                toDeleteList.push_back($$);
                int loc = CodeBuffer::instance().emit("br label @");
                pair<int,BranchLabelIndex> newPair = make_pair(loc, BranchLabelIndex::FIRST);
                dynamic_cast<Bool*>($$)->setFalseList(CodeBuffer::makelist(newPair));
                //dynamic_cast<Bool*>($$)->setLabel(CodeBuffer::instance().genLabel()); //Removed this line in 26/1
            }
;
Call:         ID LPAREN ExpList RPAREN {
                //cout << 28 << endl;
                toDeleteList.push_back($1);
                if(symbolTable.findId((dynamic_cast<Id*>($1)->id))) {
                    //cout << 28 << "a" << endl;
                    ProtoType& type = symbolTable.getIdType((dynamic_cast<Id*>($1)->id));
                    //cout << 28 << "b" << endl;
                    if(!type.isFunc()) {  //TODO: need to check if this is the right error to print
                        //delete returnType;
                        //cout << 28 << "c" << endl;
                        errorUndefFunc(yylineno, (dynamic_cast<Id*>($1)->id));
                        destroyOnExit();
                    } else {
                        //cout << 28 << "d" << endl;
                        if(type.compareArgs(dynamic_cast<ExpList*>($3)->getExpList())) {
                            $$ = new Call(type.getReturnType());
                            if ((dynamic_cast<Id*>($1)->id) == "print") {
                                string globalVar = dynamic_cast<ExpList*>($3)->getExpList()[0]->getValue(); //we know this because it's a legal call for print.
                                int len = globalDict[globalVar];
                                string reg1 = getNextReg();
                                string line = reg1 + " = getelementptr [" + std::to_string(len) + " x i8], [" + std::to_string(len) + " x i8]* " + globalVar + ", i32 0, i32 0";
                                CodeBuffer::instance().emit(line);
                                //string reg = getNextReg();
                                line = "call void @print(i8* " + reg1 + ")"; 
                                CodeBuffer::instance().emit(line);
                                //$$->setValue(reg);
                            } else {
                                string ret;
                                //ProtoType& rType = dynamic_cast<ProtoType*>(type.getReturnType());
                                if (type.getReturnType().isBool()) {
                                    ret = "i1";
                                } else if(type.getReturnType().isInt()) {
                                    ret = "i32";
                                } else if(type.getReturnType().isByte()) {
                                    ret = "i8";
                                } else {
                                    ret = "void";
                                }
                                string reg = getNextReg();
                                string line;
                                if (ret == "void") {
                                    line = "call " + ret + " @" + dynamic_cast<Id*>($1)->id + "(" + toLlvmArgs(type.getStrList(), dynamic_cast<ExpList*>($3)->getExpList()) +")";
                                } else {
                                    line = reg + " = call " + ret + " @" + dynamic_cast<Id*>($1)->id + "(" + toLlvmArgs(type.getStrList(), dynamic_cast<ExpList*>($3)->getExpList()) +")";
                                }
                                CodeBuffer::instance().emit(line);
                                $$->setValue(reg);
                            }
                        } else {
                            vector<std::string> vec = dynamic_cast<Func&>(type).getStrList();
                            errorPrototypeMismatch(yylineno, dynamic_cast<Id*>($1)->id, vec);
                            destroyOnExit();
                        }
                    }
                } else {
                    errorUndefFunc(yylineno, (dynamic_cast<Id*>($1)->id));
                    destroyOnExit();
                }
            }
			| ID LPAREN RPAREN {
                //cout << 29 << endl;
                toDeleteList.push_back($1);
                if(symbolTable.findId((dynamic_cast<Id*>($1)->id))) {
                    ProtoType& type = symbolTable.getIdType((dynamic_cast<Id*>($1)->id));
                    if(!type.isFunc()) {
                        errorUndefFunc(yylineno, (dynamic_cast<Id*>($1)->id));
                        destroyOnExit();
                    } else {
                        if(type.compareArgs()) {
                            $$ = new Call(type.getReturnType());
                            string ret;
                            if (type.getReturnType().isBool()) {
                                ret = "i1";
                            } else if(type.getReturnType().isInt()) {
                                ret = "i32";
                            } else if(type.getReturnType().isByte()) {
                                ret = "i8";
                            } else {
                                ret = "void";
                            }
                            string reg = getNextReg();
                            string line;
                            if(ret == "void") {
                                line = "call " + ret + " @" + dynamic_cast<Id*>($1)->id + " ()";
                            } else {
                                line = reg + " = call " + ret + " @" + dynamic_cast<Id*>($1)->id + " ()";
                            }
                            CodeBuffer::instance().emit(line);
                            $$->setValue(reg);
                        } else {
                            vector<std::string> vec;
                            errorPrototypeMismatch(yylineno, (dynamic_cast<Id*>($1)->id), vec);
                            destroyOnExit();
                        }
                    }
                } else {
                    errorUndefFunc(yylineno, (dynamic_cast<Id*>($1)->id));
                    destroyOnExit();    
                }
            }
;
ExpList:      ExpList COMMA Exp { /*cout << 30 << endl;*/ $$ = new ExpList(*(dynamic_cast<ProtoType*>($3)), dynamic_cast<ExpList*>($1)->getExpList()); toDeleteList.push_back($$); /*delete $1; delete $3;*/} /* maybe need to flip */
			| Exp { /*cout << 31 << endl;*/ $1->getValue(); $$ = new ExpList(*(dynamic_cast<ProtoType*>($1))); toDeleteList.push_back($$); /*delete $1;*/ } //TODO: check if exp dies in expList afterwards
;
Type:         INT { /*cout << 32 << endl;*/ $$ = new Int(); toDeleteList.push_back($$); }
    		| BYTE { /*cout <<33 << endl;*/ $$ = new Byte(); toDeleteList.push_back($$); }
    		| BOOL { /*cout << 34 << endl;*/ $$ = new Bool(); toDeleteList.push_back($$); }
;
TypeAnnotation:  CONST { /*cout << 35 << endl;*/ $$ = new TypeAnnotation(true); toDeleteList.push_back($$); }
        	    | { /*cout << 36 << endl;*/ $$ = new TypeAnnotation(); toDeleteList.push_back($$); }
;
Exp:          LPAREN Exp RPAREN {
                //cout << 37 << endl;
                $$ = $2;  //TODO: check if need to assign $2's lists to $$
                dynamic_cast<ProtoType*>($$)->setIsLiteral(false);
            }
            | Exp PRODUCT Exp {
                //cout << 38 << endl;
                if(isNumbers($1, $3)) {
                    if($1->isInt() || $3->isInt()) {
                        $$ = new Int();
                        std::string val1 = dynamic_cast<ProtoType*>($1)->getValue();
                        std::string val3 = dynamic_cast<ProtoType*>($3)->getValue();
                        std::string reg1 = getNextReg();
                        string line;
                        if ($1->isByte() && isRegister(val1)) {
                            string reg2 = getNextReg();
                            line = reg2 + " = zext i8 " + val1 + " to i32";
                            CodeBuffer::instance().emit(line);
                            line = reg1 + " = mul i32 " + reg2 + ", " + val3;
                        } else if ($3->isByte() && isRegister(val3)) {
                            string reg2 = getNextReg();
                            line = reg2 + " = zext i8 " + val3 + " to i32";
                            CodeBuffer::instance().emit(line);
                            line = reg1 + " = mul i32 " + val1 + ", " + reg2;
                        } else {
                            line = reg1 + " = mul i32 " + val1 + ", " + val3;
                        }
                        dynamic_cast<ProtoType*>($$)->setValue(reg1);
                        CodeBuffer::instance().emit(line);
                    } else {
                        $$ = new Byte();
                        std::string val1 = dynamic_cast<ProtoType*>($1)->getValue();
                        std::string val3 = dynamic_cast<ProtoType*>($3)->getValue();
                        std::string reg1 = getNextReg();
                        std::string line = reg1 + " = mul i8 " + val1 + ", " + val3;
                        CodeBuffer::instance().emit(line);
                        // std::reg2 = getNextReg();
                        // line = reg2 + " = trunc i32 " + reg1 + " to i8";
                        // CodeBuffer::instance().emit(line);
                        dynamic_cast<ProtoType*>($$)->setValue(reg1); // need to change to reg2 if the above is not a comment
                    }
                    toDeleteList.push_back($$);
                } else {
                    output::errorMismatch(yylineno);
                    destroyOnExit();
                }
            }
            | Exp DEVISION Exp {
                //cout << 38 << endl;
                if(isNumbers($1, $3)) {
                    std::string val1 = dynamic_cast<ProtoType*>($1)->getValue();
                    std::string val3 = dynamic_cast<ProtoType*>($3)->getValue();
                    string tReg;
                    if($3->isByte()) {
                        tReg = getNextReg();
                        string tmp = tReg + " = zext i8 " + val3 + " to i32";
                        CodeBuffer::instance().emit(tmp);
                    } else {
                        tReg = val3;
                    }
                    string cond = getNextReg();
                    std::string line = cond + " = icmp eq i32 " + tReg + ", 0";
                    CodeBuffer::instance().emit(line);
                    string trueLabel = "trueLabel" + std::to_string(regCounter);
                    string falseLabel = "falseLabel" + std::to_string(regCounter);
                    line = "br i1 " + cond + ", label %" + trueLabel + ", label %" + falseLabel;
                    CodeBuffer::instance().emit(line);
                    CodeBuffer::instance().emit(trueLabel + ":");
                    string div = "%divError" + std::to_string(regCounter);
                    line = div + " = getelementptr [23 x i8], [23 x i8]* @.devision_by_zero, i32 0, i32 0";
                    CodeBuffer::instance().emit(line);
                    CodeBuffer::instance().emit("call void @print(i8* " + div + ")");
                    CodeBuffer::instance().emit("call void @exit(i32 1)");
                    CodeBuffer::instance().emit("br label %" + falseLabel);
                    // %cond = icmp eq i32 val3, 0
                    // br %cond <trueLabel> <falseLabel>
                    CodeBuffer::instance().emit(falseLabel + ":");
                    if($1->isInt() || $3->isInt()) {
                        $$ = new Int();
                        std::string reg1 = getNextReg();
                        if ($1->isByte() && isRegister(val1)) {
                            string reg2 = getNextReg();
                            line = reg2 + " = zext i8 " + val1 + " to i32";
                            CodeBuffer::instance().emit(line);
                            line = reg1 + " = sdiv i32 " + reg2 + ", " + val3;
                        } else if ($3->isByte() && isRegister(val3)) {
                            string reg2 = getNextReg();
                            line = reg2 + " = zext i8 " + val3 + " to i32";
                            CodeBuffer::instance().emit(line);
                            line = reg1 + " = sdiv i32 " + val1 + ", " + reg2;
                        } else {
                            line = reg1 + " = sdiv i32 " + val1 + ", " + val3;
                        }
                        //line = reg1 + " = sdiv i32 " + val1 + ", " + val3;
                        dynamic_cast<ProtoType*>($$)->setValue(reg1);
                        CodeBuffer::instance().emit(line);
                    } else {
                        $$ = new Byte();
                        string reg1 = getNextReg();
                        std::string line = reg1 + " = udiv i8 " + val1 + ", " + val3;
                        dynamic_cast<ProtoType*>($$)->setValue(reg1);
                        CodeBuffer::instance().emit(line);                        
                    }
                    toDeleteList.push_back($$);
                } else {
                    output::errorMismatch(yylineno);
                    destroyOnExit();
                }
            }
            /*
            | Exp PRODUCT_DEVISION Exp {
                cout << 38 << endl;
                if(isNumbers($1, $3)) {
                    if($1->isInt() || $3->isInt()) {
                        $$ = new Int();
                    } else {
                        $$ = new Byte();
                    }
                    toDeleteList.push_back($$);
                } else {
                    output::errorMismatch(yylineno);
                    destroyOnExit();
                }
            }
            */
            | Exp PLUS Exp {
                //cout << 39 << endl;
                if(isNumbers($1, $3)) {
                    string reg1;
                    string line;
                    if($1->isInt() || $3->isInt()) {                        
                        $$ = new Int();
                        std::string val1 = dynamic_cast<ProtoType*>($1)->getValue();
                        std::string val3 = dynamic_cast<ProtoType*>($3)->getValue();
                        reg1 = getNextReg();
                        line;
                        if ($1->isByte() && isRegister(val1)) {
                            string reg2 = getNextReg();
                            line = reg2 + " = zext i8 " + val1 + " to i32";
                            CodeBuffer::instance().emit(line);
                            line = reg1 + " = add i32 " + reg2 + ", " + val3;
                        } else if ($3->isByte() && isRegister(val3)) {
                            string reg2 = getNextReg();
                            line = reg2 + " = zext i8 " + val3 + " to i32";
                            CodeBuffer::instance().emit(line);
                            line = reg1 + " = add i32 " + val1 + ", " + reg2;
                        } else {
                            line = reg1 + " = add i32 " + val1 + ", " + val3;
                        }                        
                        //line = reg1 + " = add i32 " + val1 + ", " + val3;
                    } else {
                        $$ = new Byte();
                        std::string val1 = dynamic_cast<ProtoType*>($1)->getValue();
                        std::string val3 = dynamic_cast<ProtoType*>($3)->getValue();
                        reg1 = getNextReg();
                        line = reg1 + " = add i8 " + val1 + ", " + val3;                     
                    }
                    dynamic_cast<ProtoType*>($$)->setValue(reg1);
                    CodeBuffer::instance().emit(line);
                    toDeleteList.push_back($$);
                } else {
                    output::errorMismatch(yylineno);
                    destroyOnExit();
                }
            }
            | Exp MINUS Exp {
                //cout << 39 << endl;
                if(isNumbers($1, $3)) {
                    std::string val1 = dynamic_cast<ProtoType*>($1)->getValue();
                    std::string val3 = dynamic_cast<ProtoType*>($3)->getValue();
                    std::string reg1 = getNextReg();
                    string line;
                    if($1->isInt() || $3->isInt()) {                        
                        $$ = new Int();
                        if ($1->isByte() && isRegister(val1)) {
                            string reg2 = getNextReg();
                            line = reg2 + " = zext i8 " + val1 + " to i32";
                            CodeBuffer::instance().emit(line);
                            line = reg1 + " = sub i32 " + reg2 + ", " + val3;
                        } else if ($3->isByte() && isRegister(val3)) {
                            string reg2 = getNextReg();
                            line = reg2 + " = zext i8 " + val3 + " to i32";
                            CodeBuffer::instance().emit(line);
                            line = reg1 + " = sub i32 " + val1 + ", " + reg2;
                        } else {
                            line = reg1 + " = sub i32 " + val1 + ", " + val3;
                        }
                        //line = reg1 + " = sub i32 " + val1 + ", " + val3;
                    } else {
                        $$ = new Byte();
                        line = reg1 + " = sub i8 "  + val1 + ", " + val3; // TODO: need to check how to handle unsigned byte
                    }
                    dynamic_cast<ProtoType*>($$)->setValue(reg1);
                    CodeBuffer::instance().emit(line);
                    toDeleteList.push_back($$);
                } else {
                    output::errorMismatch(yylineno);
                    destroyOnExit();
                }
            }
            /*
            | Exp PLUS_MINUS Exp {
                cout << 39 << endl;
                if(isNumbers($1, $3)) {
                    if($1->isInt() || $3->isInt()) {                        
                        $$ = new Int();
                    } else {
                        $$ = new Byte();
                    }
                    toDeleteList.push_back($$);
                } else {
                    output::errorMismatch(yylineno);
                    destroyOnExit();
                }
            }
            */
			| ID {
                //cout << 40 << endl;
                toDeleteList.push_back($1);
                if(symbolTable.findId((dynamic_cast<Id*>($1)->id))) {
                    //cout << "40a" << endl;
                    ProtoType& type = symbolTable.getIdType((dynamic_cast<Id*>($1)->id));
                    if(type.isFunc()) {  //TODO: need to check if this is the right error to print
                        errorUndef(yylineno, (dynamic_cast<Id*>($1)->id));
                        destroyOnExit();
                    } else {
                        $$ = type.clone();
                        toDeleteList.push_back($$);
                        dynamic_cast<ProtoType*>($$)->setIsLiteral(false);
                        //cout << "40b" << endl;
                        if(type.getIsConst() && type.getIsLiteral()) {
                            //cout << "40c" << endl;
                            dynamic_cast<ProtoType*>($$)->setValue(symbolTable.getValueById(dynamic_cast<Id*>($1)->id));
                            if(type.isBool()) {
                                //cout << "test" << endl;
                                int place = CodeBuffer::instance().emit("br i1 " + dynamic_cast<ProtoType*>($$)->getValue() + ", label @, label @");
                                std::pair<int,BranchLabelIndex> newPair1 = std::make_pair(place, BranchLabelIndex::FIRST); //TODO: check if this line is right
                                dynamic_cast<Bool*>($$)->setTrueList(CodeBuffer::makelist(newPair1));
                                std::pair<int,BranchLabelIndex> newPair2 = std::make_pair(place, BranchLabelIndex::SECOND); //TODO: check if this line is right
                                dynamic_cast<Bool*>($$)->setFalseList(CodeBuffer::makelist(newPair2));                                
                            }
                            //cout << "40d" << endl;
                        } else {
                            //cout << "40e" << endl;
                            int idOffset = symbolTable.getAbsoluteOffset(dynamic_cast<Id*>($1)->id);
                            std::string reg1 = getNextReg();
                            std::string tmpLine = reg1 + " = getelementptr i32, i32* %stack, i32 " + to_string(idOffset);
                            CodeBuffer::instance().emit(tmpLine);
                            std::string reg2 = getNextReg();
                            tmpLine = reg2 + " = load i32, i32* " + reg1;
                            dynamic_cast<ProtoType*>($$)->setValue(reg2);
                            CodeBuffer::instance().emit(tmpLine);
                            std::string reg3 = getNextReg();
                            if(type.isBool()) { //alon said this is good |:^D
                                tmpLine = reg3 + " = trunc i32 " + reg2 + " to i1";
                                CodeBuffer::instance().emit(tmpLine);
                                dynamic_cast<ProtoType*>($$)->setValue(reg3);
                                int place = CodeBuffer::instance().emit("br i1 " + reg3 + ", label @, label @");
                                std::pair<int,BranchLabelIndex> newPair1 = std::make_pair(place, BranchLabelIndex::FIRST); //TODO: check if this line is right
                                dynamic_cast<Bool*>($$)->setTrueList(CodeBuffer::makelist(newPair1));
                                std::pair<int,BranchLabelIndex> newPair2 = std::make_pair(place, BranchLabelIndex::SECOND); //TODO: check if this line is right
                                dynamic_cast<Bool*>($$)->setFalseList(CodeBuffer::makelist(newPair2));
                            } else if(type.isByte()) {
                                tmpLine = reg3 + " = trunc i32 " + reg2 + " to i8";
                                CodeBuffer::instance().emit(tmpLine);
                                dynamic_cast<ProtoType*>($$)->setValue(reg3);
                            }
                            //cout << "40f" << endl;
                        }
                    }
                } else { 
                    errorUndef(yylineno, (dynamic_cast<Id*>($1)->id));
                    destroyOnExit();
                }
            }
			| Call { /*cout << 41 << endl;*/ $$ = dynamic_cast<Call*>($1)->getReturnType(); $$->setValue($1->getValue()); }  //TODO: do it
            | NUM B { 
                //cout << 42 << endl;
                toDeleteList.push_back($1);
                if (((dynamic_cast<Num*>($1)->num) < 0)) {
                    dynamic_cast<Num*>($1)->num &= ((1 << 8) - 1); //TODO: is this mashlim Le'Two? (8-bit)
                }
                if (((dynamic_cast<Num*>($1)->num) > 255)) {
                    errorByteTooLarge(yylineno, to_string(((dynamic_cast<Num*>($1)->num))));
                    destroyOnExit();
                } else {
                    $$ = new Byte(true); 
                    toDeleteList.push_back($$);
                    dynamic_cast<ProtoType*>($$)->setValue(std::to_string(dynamic_cast<Num*>($1)->num));
                }
            } /* maybe need to flip */
            | NUM { /*//cout << 43 << endl;*/ $$ = new Int(true); toDeleteList.push_back($$); toDeleteList.push_back($1); dynamic_cast<ProtoType*>($$)->setValue(std::to_string(dynamic_cast<Num*>($1)->num)); }
			| STRING {
                //cout << 44 << endl; 
                $$ = new String(); 
                toDeleteList.push_back($$);
                string varName = getNextGlobal();
                dynamic_cast<ProtoType*>($$)->setValue(varName);
                int strLen = dynamic_cast<StringVal*>($1)->str.length() + 1; //because we want \00 in the end
                //cout << "this is the StringVal" << endl;
                //cout << dynamic_cast<StringVal*>($1)->str << endl;
                string line = varName + " = constant [" + std::to_string(strLen) + " x i8] c\"" + dynamic_cast<StringVal*>($1)->str + "\\00\""; 
                globalDict[varName] = strLen;
                CodeBuffer::instance().emitGlobal(line);
            }
			| TRUE {
                //cout << 45 << endl; 
                $$ = new Bool(BoolType::B_TRUE, true); 
                toDeleteList.push_back($$); 
                int place = CodeBuffer::instance().emit("br i1 true, label @, label @");
                std::pair<int,BranchLabelIndex> newPair = std::make_pair(place, BranchLabelIndex::FIRST); //TODO: check if this line is right
                dynamic_cast<Bool*>($$)->setTrueList(CodeBuffer::makelist(newPair));
                newPair = std::make_pair(place, BranchLabelIndex::SECOND); 
                dynamic_cast<Bool*>($$)->setFalseList(CodeBuffer::makelist(newPair));
            }
            | FALSE { 
                //cout << 46 << endl;
                $$ = new Bool(BoolType::B_FALSE, true); 
                toDeleteList.push_back($$); 
                int place = CodeBuffer::instance().emit("br i1 false, label @, label @");
                std::pair<int,BranchLabelIndex> newPair = std::make_pair(place, BranchLabelIndex::SECOND); //TODO: check if this line is right
                dynamic_cast<Bool*>($$)->setFalseList(CodeBuffer::makelist(newPair));
                newPair = std::make_pair(place, BranchLabelIndex::FIRST);
                dynamic_cast<Bool*>($$)->setTrueList(CodeBuffer::makelist(newPair));
            }
			| NOT Exp {
                //cout << 47 << endl;
                if($2->isBool()) {
                    $$ = new Bool();
                    toDeleteList.push_back($$);
                    dynamic_cast<Bool*>($$)->setTrueList(dynamic_cast<Bool*>($2)->getFalseList());
                    dynamic_cast<Bool*>($$)->setFalseList(dynamic_cast<Bool*>($2)->getTrueList());
                } else {
                    output::errorMismatch(yylineno);
                    destroyOnExit();
                }
            }
            | Exp AND { $$ = new Bool(); toDeleteList.push_back($$); dynamic_cast<Bool*>($$)->setLabel(CodeBuffer::instance().genLabel()); } Exp {
                //cout << 48 << endl;
                if(isBools($1, $4)) { //it was $3 do we need to change?
                    $$ = new Bool();
                    toDeleteList.push_back($$);
                    //Bool* marker = $3;
                    //$$->setLabel(marker->getLabel());
                    dynamic_cast<Bool*>($$)->setLabel(dynamic_cast<Bool*>($3)->getLabel());
                    CodeBuffer::instance().bpatch(dynamic_cast<Bool*>($1)->getTrueList(), dynamic_cast<Bool*>($3)->getLabel());
                    dynamic_cast<Bool*>($$)->setFalseList(CodeBuffer::instance().merge(dynamic_cast<Bool*>($1)->getFalseList(), dynamic_cast<Bool*>($4)->getFalseList()));
                    dynamic_cast<Bool*>($$)->setTrueList(dynamic_cast<Bool*>($4)->getTrueList());
                    
                } else {
                    output::errorMismatch(yylineno);
                    destroyOnExit();
                }
            }
            | Exp OR { $$ = new Bool(); toDeleteList.push_back($$); dynamic_cast<Bool*>($$)->setLabel(CodeBuffer::instance().genLabel()); } Exp {
                //cout << 49 << endl;
                if(isBools($1, $4)) { //it was $3 do we need to change?
                    $$ = new Bool();
                    toDeleteList.push_back($$);
                    dynamic_cast<Bool*>($$)->setLabel(dynamic_cast<Bool*>($3)->getLabel());
                    CodeBuffer::instance().bpatch(dynamic_cast<Bool*>($1)->getFalseList(), dynamic_cast<Bool*>($3)->getLabel());
                    dynamic_cast<Bool*>($$)->setTrueList(CodeBuffer::instance().merge(dynamic_cast<Bool*>($1)->getTrueList(), dynamic_cast<Bool*>($4)->getTrueList()));
                    dynamic_cast<Bool*>($$)->setFalseList(dynamic_cast<Bool*>($4)->getFalseList());
                } else {
                    output::errorMismatch(yylineno);
                    destroyOnExit();
                }
            }
            | Exp RELOP_RELATION Exp {
                //cout << 50 << endl;
                if(isNumbers($1, $3)) {
                    $$ = new Bool();
                    toDeleteList.push_back($$);
                    toDeleteList.push_back($2);
                    string line;
                    string reg1 = getNextReg();
                    if($1->isByte() && $3->isByte()) {
                        line = reg1 + " = icmp u" + dynamic_cast<RelopRelation*>($2)->opSuffix + " i8 " + dynamic_cast<ProtoType*>($1)->getValue() + ", " + dynamic_cast<ProtoType*>($3)->getValue();
                    } else {
                        string val1 = dynamic_cast<ProtoType*>($1)->getValue(), val2 = dynamic_cast<ProtoType*>($3)->getValue();
                        if($1->isByte()) {
                            string reg2 = getNextReg();
                            line = reg2 + " = zext i8 " + dynamic_cast<ProtoType*>($1)->getValue() + " to i32";
                            CodeBuffer::instance().emit(line);
                            val1 = reg2;
                        } else if($3->isByte()) {
                            string reg2 = getNextReg();
                            line = reg2 + " = zext i8 " + dynamic_cast<ProtoType*>($3)->getValue() + " to i32";
                            CodeBuffer::instance().emit(line);
                            val2 = reg2;
                        }
                        line = reg1 + " = icmp s" + dynamic_cast<RelopRelation*>($2)->opSuffix + " i32 " + val1 + ", " + val2;
                    }
                    CodeBuffer::instance().emit(line);
                    line = "br i1 " + reg1 + ", label @, label @";
                    int place = CodeBuffer::instance().emit(line);
                    std::pair<int,BranchLabelIndex> newPair = std::make_pair(place, BranchLabelIndex::FIRST);
                    dynamic_cast<Bool*>($$)->setTrueList(CodeBuffer::makelist(newPair));
                    newPair = std::make_pair(place, BranchLabelIndex::SECOND);
                    dynamic_cast<Bool*>($$)->setFalseList(CodeBuffer::makelist(newPair));
                } else {
                    output::errorMismatch(yylineno);
                    destroyOnExit();
                }
            }
            | Exp RELOP_EQ Exp {
                //cout << 51 << endl;
                if(isNumbers($1, $3)) {
                    $$ = new Bool();
                    toDeleteList.push_back($$);
                    toDeleteList.push_back($2);
                    string line;
                    string reg1 = getNextReg();
                    if($1->isByte() && $3->isByte()) {
                        line = reg1 + " = icmp " + dynamic_cast<RelopEq*>($2)->op + " i8 " + dynamic_cast<ProtoType*>($1)->getValue() + ", " + dynamic_cast<ProtoType*>($3)->getValue();
                    } else {
                        string val1 = dynamic_cast<ProtoType*>($1)->getValue(), val2 = dynamic_cast<ProtoType*>($3)->getValue();
                        if($1->isByte()) {
                            string reg2 = getNextReg();
                            line = reg2 + " = zext i8 " + dynamic_cast<ProtoType*>($1)->getValue() + " to i32";
                            CodeBuffer::instance().emit(line);
                            val1 = reg2;
                        } else if($3->isByte()) {
                            string reg2 = getNextReg();
                            line = reg2 + " = zext i8 " + dynamic_cast<ProtoType*>($3)->getValue() + " to i32";
                            CodeBuffer::instance().emit(line);
                            val2 = reg2;
                        }
                        line = reg1 + " = icmp " + dynamic_cast<RelopEq*>($2)->op + " i32 " + val1 + ", " + val2;
                    }
                    CodeBuffer::instance().emit(line);
                    line = "br i1 " + reg1 + ", label @, label @";
                    int place = CodeBuffer::instance().emit(line);
                    std::pair<int,BranchLabelIndex> newPair = std::make_pair(place, BranchLabelIndex::FIRST);
                    dynamic_cast<Bool*>($$)->setTrueList(CodeBuffer::makelist(newPair));
                    newPair = std::make_pair(place, BranchLabelIndex::SECOND);
                    dynamic_cast<Bool*>($$)->setFalseList(CodeBuffer::makelist(newPair));
                } else {
                    output::errorMismatch(yylineno);
                    destroyOnExit();
                }
            }
            | LPAREN Type RPAREN Exp {
                //cout << 52 << endl;
                if($4->isInt()) {
                    if($2->isBool()) {
                        output::errorMismatch(yylineno);
                        destroyOnExit();
                    }
                    if($2->isInt()) {
                        $$ = new Int();
                        toDeleteList.push_back($$);
                        dynamic_cast<ProtoType*>($$)->setValue(dynamic_cast<ProtoType*>($4)->getValue());
                    } else {
                        $$ = new Byte();
                        toDeleteList.push_back($$);
                        string reg1 = getNextReg();
                        string line = reg1 + " = trunc i32 " + dynamic_cast<ProtoType*>($4)->getValue() + " to i8";
                        CodeBuffer::instance().emit(line);
                        dynamic_cast<ProtoType*>($$)->setValue(reg1);
                    }
                } else if($4->isByte()) {
                    if($2->isBool()) {
                        output::errorMismatch(yylineno);
                        destroyOnExit();
                    }
                    if($2->isInt()) {
                        $$ = new Int();
                        toDeleteList.push_back($$);
                        string reg1 = getNextReg();
                        string line = reg1 + " = zext i8 " + dynamic_cast<ProtoType*>($4)->getValue() + " to i32";
                        CodeBuffer::instance().emit(line);
                        dynamic_cast<ProtoType*>($$)->setValue(reg1);
                    } else {
                        $$ = new Byte();
                        toDeleteList.push_back($$);
                        dynamic_cast<ProtoType*>($$)->setValue(dynamic_cast<ProtoType*>($4)->getValue());
                    }
                } else if($4->isBool()) {
                    if(!$2->isBool()) {
                        output::errorMismatch(yylineno);
                        destroyOnExit();
                    }
                    $$ = new Bool();
                    toDeleteList.push_back($$);
                    dynamic_cast<ProtoType*>($$)->setValue(dynamic_cast<ProtoType*>($4)->getValue());
                } else {
                    output::errorMismatch(yylineno);
                    destroyOnExit();
                }
            }
;
%%
/* C user routines */
void yyerror(const char*) {
    output::errorSyn(yylineno); 
    destroyOnExit();
}

bool isNumbers(const Object* type1, const Object* type2) {
    return (type1->isInt() || type1->isByte()) && (type2->isInt() || type2->isByte());
}

bool isBools(const Object* type1, const Object* type2) {
    return type1->isBool() && type2->isBool();
}

void destroyAll() {
    for(auto p : toDeleteList) {
        delete p;
    }
}

void destroyOnExit() {
    destroyAll();
    exit(0);
}

void endOfScope() {
    //endScope();
    /* cout << symbolTable.top(); */
    symbolTable.pop();
    /* endScope(); */
}

bool isRegister(std::string val) {
    return (val[0] == '%' || val[0] == '@');
}

std::string toLlvmTypes(std::vector<ProtoType*> types) {
    ////cout << "start of toLlvmTypes" << endl;
    string str = "";
    int len = types.size();
    //cout << len << endl;
    for(int i = 0; i < len - 1; ++i) {
        if(types[i]->isBool()) {
            str += "i1, ";
        } else if(types[i]->isByte()) {
            str += "i8, ";
        } else if(types[i]->isInt()) {
            str += "i32, ";
        }
    }
    //cout << "end of for" << endl;
    if (len > 0) {
        if(types[len - 1]->isBool()) {
            str += "i1";
        } else if(types[len - 1]->isByte()) {
            str += "i8";
        } else if(types[len - 1]->isInt()) {
            str += "i32";
        }
    }
    //cout << "end of toLlvmTypes" << endl;
    return str;
}

std::string toLlvmArgs(std::vector<std::string> typesOfFunc, std::vector<ProtoType*> args) {
    string str = "";
    int len = args.size();
    for(int i = 0; i < len - 1; ++i) {
        if(args[i]->isBool()) {
            str += "i1 " + args[i]->getValue() + ", "; //dont need dynamic cast because getValue is in Object
        } else if(args[i]->isByte()) {
            //check if need to auto transform byte to int
            if(typesOfFunc[i] == "INT") {
                string reg = getNextReg();
                string line = reg + " = zext i8 " + args[i]->getValue() + " to i32";
                CodeBuffer::instance().emit(line);
                str += "i32 " + reg + ", ";
            } else {
                str += "i8 " + args[i]->getValue() + ", ";
            }
        } else if(args[i]->isInt()) {
            str += "i32 " + args[i]->getValue() + ", ";
        }
    }
    if(args[len - 1]->isBool()) {
        str += "i1 " + args[len - 1]->getValue();
    } else if(args[len - 1]->isByte()) {
        if(typesOfFunc[len - 1] == "INT") {
            string reg = getNextReg();
            string line = reg + " = zext i8 " + args[len - 1]->getValue() + " to i32";
            CodeBuffer::instance().emit(line);
            str += "i32 " + reg;        
        } else {
            str += "i8 " + args[len - 1]->getValue();
        }   
    } else if(args[len - 1]->isInt()) {
        str += "i32 " + args[len - 1]->getValue();
    }
    return str;
}

std::string getNextReg() {
    string name = "%t";
    name += std::to_string(regCounter++);
    return name;
}

std::string getNextGlobal() {
    string name = "@.g";
    return name + std::to_string(regCounter++);
}

void initialEmit() {
    CodeBuffer::instance().emitGlobal("declare i32 @printf(i8*, ...)");
    CodeBuffer::instance().emitGlobal("declare void @exit(i32)");
    CodeBuffer::instance().emitGlobal("@.int_specifier = constant [4 x i8] c\"\%d\\0A\\00\"");
    CodeBuffer::instance().emitGlobal("@.str_specifier = constant [4 x i8] c\"\%s\\0A\\00\"");
    CodeBuffer::instance().emitGlobal("@.devision_by_zero = constant [23 x i8] c\"Error division by zero\\00\"");
    CodeBuffer::instance().emit("define void @printi(i32) {");
    CodeBuffer::instance().emit("\%spec_ptr = getelementptr [4 x i8], [4 x i8]* @.int_specifier, i32 0, i32 0");
    CodeBuffer::instance().emit("call i32 (i8*, ...) @printf(i8* \%spec_ptr, i32 %0)");
    CodeBuffer::instance().emit("ret void");
    CodeBuffer::instance().emit("}");
    CodeBuffer::instance().emit("define void @print(i8*) {");
    CodeBuffer::instance().emit("\%spec_ptr = getelementptr [4 x i8], [4 x i8]* @.str_specifier, i32 0, i32 0");
    CodeBuffer::instance().emit("call i32 (i8*, ...) @printf(i8* \%spec_ptr, i8* %0)");
    CodeBuffer::instance().emit("ret void");
    CodeBuffer::instance().emit("}");
}

int main() {
    yyparse();
    if(!symbolTable.isMainExists()) {
        errorMainMissing();
        destroyOnExit();
    }
    //endScope();
    /* cout << symbolTable.top(); */
    CodeBuffer::instance().printGlobalBuffer();
    CodeBuffer::instance().printCodeBuffer();
    symbolTable.pop();
    destroyAll();
}
